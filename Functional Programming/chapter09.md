### 계층형 설계

> 두번째 시간

### 패턴 2 - 추상화의 벽 abstraction barrier

> 팀 간 책임을 명확하게 나눔

##### 세부 구현을 감춘 함수로 이루어진 계층

> 마치 라이브러리나 API와 같다.

#### 언제 쓰면 좋을지?

1. 쉽게 구현을 바꾸려고 할 떄
2. 코드를 일고 쓰기 쉽게 만들때
3. 팀 간의 조율 줄일때
4. 주어진 문제에 집중할 때

#### 패턴 3 - 작은 인터페이스 minimal interface

> 새로운 코드를 추가할 위치에 관한 것

##### 상위 계층의 함수를 만들 때 가능한 현재 계층에 있는 함수로 구현하는 것이 작은 인터페이스를 실천하는 방법.

#### 패턴 4 - 편리한 계층 comfortable layers

> 앞서 다뤘던 패턴 3가지와는 다르게 더 현실적이고 실용적인 측면을 다룸

##### 언제 패턴을 적용하고 언제 멈춰야 하는지 실용적인 방법을 알려줌

> 지금 작업하는 코드가 편리한가? 그렇다면 설계는 조금 멈춰도 된다.

#### 호출 그래프

> 함수가 어떤 함수를 호출하는지 있는 그대로 보여줌

##### 3가지 중요한 비기능적 요구사항 nonfunctional requirements NFRs 을 꾸밈없이 보여줌

🤔 기능적 요구사항 functional requirements 이란 소프트웨어가 정확히 해야 하는 일을 말함

##### ✅ 3가지 비기능적 요구사항

1. 유지보수성 maintainability => 요구사항 변경시, 가장 쉽게 고칠 수 있는 코드는?
2. 테스트성 testability => 어떤 것을 테스트 하는 것이 가장 중요한지?
3. 재사용성 reusability => 어떤 함수가 재사용하기 좋은지?

4. 가장 위에있는 코드가 고치기 가장 쉬워요
   > 함수 그래프는 위에서 멀어질수록 더 고치기 어렵다
5. 아래에 있는 코드는 테스트가 중요해요
   > 제대로 만들었다면 가장 아래에 있는 코드보다, 가장 위에 있는 코드가 더 자주 바뀐다
6. 아래에 있는 코드가 재사용하기 좋아요
   > 아래쪽을 가리키는 화살표가 많은 함수는 재사용하기 어렵다
